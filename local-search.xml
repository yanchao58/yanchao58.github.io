<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常见的排序算法总结</title>
    <link href="/2021/05/22/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2021/05/22/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1-常见的排序算法"><a href="#1-常见的排序算法" class="headerlink" title="1 常见的排序算法"></a>1 常见的排序算法</h2><h3 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h3><p><strong>思想：</strong></p><p>第一轮，从第一个元素开始直到最后一个元素，比较相邻的元素，若前一个元素比后一个元素大，那么就交换，一轮下来，最大的元素就会在最后一个位置。</p><p>第二轮，从第一个元素开始直到倒数第二个元素，重复以上步骤。</p><p>以此类推，假设数组长度为n，则一共经过n-1轮后，数组会排好序。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[j] &gt; nums[j + <span class="hljs-number">1</span>])&#123;<br>                swap(nums,j,j + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>时间复杂度：$O(n^2)$。</p><p>空间复杂度：$O(1)$。</p><p>稳定性：稳定。</p><h3 id="1-2-插入排序"><a href="#1-2-插入排序" class="headerlink" title="1.2 插入排序"></a>1.2 插入排序</h3><p><strong>思想：</strong></p><p>在待排序的数组中，假设前面n-1个元素已经是有序的了，然后把第n个数插入到前面的有序数组，形成n个元素的有序数组。以此类推。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-keyword">if</span>(nums[j] &lt; nums[j-<span class="hljs-number">1</span>])&#123;<br>                swap(nums,j,j-<span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>时间复杂度：$O(n^2)$。</p><p>空间复杂度：$O(1)$。</p><p>稳定性：稳定。</p><h3 id="1-3-选择排序"><a href="#1-3-选择排序" class="headerlink" title="1.3 选择排序"></a>1.3 选择排序</h3><p><strong>思想：</strong></p><p>首先，从数组中找出最小的元素，将它与第一个元素交换，然后在除第一个元素之外的剩余元素中找到最小的元素，与第二个元素交换。以此类推。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">int</span> minIndex = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[j] &lt; nums[minIndex])&#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        swap(nums,i,minIndex);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>时间复杂度：$O(n^2)$。</p><p>空间复杂度：$O(1)$。</p><p>稳定性：不稳定。</p><h3 id="1-4-希尔排序"><a href="#1-4-希尔排序" class="headerlink" title="1.4 希尔排序"></a>1.4 希尔排序</h3><p><strong>思想：</strong></p><p>希尔排序对插入排序做了点改进，先把数组局部排好序，然后最后再插入排序。具体就是让数组中任意距离为h的元素都是有序的，一个h有序的数组相当于h个相互独立的有序数组组织在一起的数组。当h为1的时候，相当于做的是插入排序。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span> h = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//选取合适的h初值</span><br>    <span class="hljs-keyword">while</span>(h &lt; n / <span class="hljs-number">3</span>)&#123;<br>        h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(h &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &gt;= h; j -= h)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j] &lt; nums[j - h])&#123;<br>                    swap(nums,j,j - h);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        h /= <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>时间复杂度：$O(n^{1.3})$。</p><p>空间复杂度：$O(1)$。</p><p>稳定性：不稳定。</p><h3 id="1-5-归并排序"><a href="#1-5-归并排序" class="headerlink" title="1.5 归并排序"></a>1.5 归并排序</h3><p><strong>思想：</strong></p><p>采用分治的思想，先将数组的两个子数组排好序，再把它们合并成一个整体有序的数组。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>    mergeSort(nums,left,mid,temp);<br>    mergeSort(nums,mid + <span class="hljs-number">1</span>,right,temp);<br>    <span class="hljs-comment">//归并</span><br>    <span class="hljs-keyword">int</span> i = left;<br>    <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> index = left;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &lt;= nums[j])&#123;<br>            temp[index++] = nums[i++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            temp[index++] = nums[j++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid)&#123;<br>        temp[index++] = nums[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j &lt;= right)&#123;<br>        temp[index++] = nums[j++];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = left; k &lt;= right; k++)&#123;<br>        nums[k] = temp[k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>时间复杂度：$O(nlog_2n)$。</p><p>空间复杂度：$O(n)$。</p><p>稳定性：稳定。</p><h3 id="1-6-快速排序"><a href="#1-6-快速排序" class="headerlink" title="1.6 快速排序"></a>1.6 快速排序</h3><p><strong>思想：</strong></p><p>首先选取一个基准（一般选数组第一个元素），把数组中小于基准值的元素全放到基准值的左边，大于基准值的元素全放到基准值的右边。再对基准值左右两边的数组重复此操作。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> key = nums[left];<br>    <span class="hljs-keyword">int</span> first = left;<br>    <span class="hljs-keyword">int</span> last = right;<br>    <span class="hljs-keyword">while</span>(first &lt; last)&#123;<br>        <span class="hljs-keyword">while</span>(first &lt; last &amp;&amp; nums[last] &gt;= key)&#123;<br>            last--;<br>        &#125;<br>        nums[first] = nums[last];<br>        <span class="hljs-keyword">while</span>(first &lt; last &amp;&amp; nums[first] &lt;= key)&#123;<br>            first++;<br>        &#125;<br>        nums[last] = nums[first];<br>    &#125;<br>    nums[first] = key;<br>    quickSort(nums,left,first - <span class="hljs-number">1</span>);<br>    quickSort(nums,first + <span class="hljs-number">1</span>,right);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>时间复杂度：$O(nlog_2n)$。</p><p>空间复杂度：$O(nlog_2n)$。</p><p>稳定性：不稳定。</p><h3 id="1-7-堆排序"><a href="#1-7-堆排序" class="headerlink" title="1.7 堆排序"></a>1.7 堆排序</h3><p><strong>思想：</strong></p><p>堆是一个近似完全二叉树的结构，根节点总是存放最大值或者最小值。</p><p>假设数组长度为n，以大顶堆为例，将待排序数组构造成一个大顶堆，此时堆的根节点存放的就是最大值，然后将最大值与数组的末尾元素交换，再把剩下的n-1个元素重新构造成一个大顶堆，重复操作，数组就会排好序。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">//构造大顶堆，从最后一个非叶节点开始</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        adjustHeap(nums,i,n);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-comment">//每次构造完大顶堆后，数组的第一个元素都是最大值，将其交换到末尾</span><br>        swap(nums,<span class="hljs-number">0</span>,i);<br>        <span class="hljs-comment">//交换元素后，调整堆结构，使其仍然保持为大顶堆</span><br>        <span class="hljs-comment">//从索引为0的节点开始调整，是因为下层的节点仍然满足大顶堆的要求，不受交换元素的影响</span><br>        adjustHeap(nums,<span class="hljs-number">0</span>,i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> root, <span class="hljs-keyword">int</span> heapSize)</span></span>&#123;<br>    <span class="hljs-comment">//j保存根节点的索引</span><br>    <span class="hljs-keyword">int</span> j = root;<br>    <span class="hljs-comment">//使用循环，是因为在调整高层节点的结构时可能会影响下层节点的结构</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span> * root + <span class="hljs-number">1</span>; k &lt; heapSize; k = <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(k + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; nums[k] &lt; nums[k + <span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-comment">//使k指向最大的子节点</span><br>            k++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[j] &lt; nums[k])&#123;<br>            swap(nums,j,k);<br>            j = k;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>时间复杂度：$O(nlog_2n)$。</p><p>空间复杂度：$O(1)$。</p><p>稳定性：不稳定。</p><h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2 总结"></a>2 总结</h2><div class="table-container"><table><thead><tr><th style="text-align:center">排序方法</th><th style="text-align:center">时间复杂度（平均）</th><th>时间复杂度（最好）</th><th>时间复杂度（最坏）</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">$O(n^{1.3})$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">$O(nlog_2n)$</td><td>$O(nlog_2n)$</td><td>$O(nlog_2n)$</td><td>$O(n)$</td><td>稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">$O(nlog_2n)$</td><td>$O(nlog_2n)$</td><td>$O(n^2)$</td><td>$O(nlog_2n)$</td><td>不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">$O(nlog_2n)$</td><td>$O(nlog_2n)$</td><td>$O(nlog_2n)$</td><td>$O(1)$</td><td>不稳定</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
