<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解虚拟内存机制-01</title>
    <link href="/2021/06/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6-01/"/>
    <url>/2021/06/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6-01/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>虚拟内存是现代操作系统中存储器管理的一项重要技术，实现了内存扩充功能。但并不是从物理上实际扩大内存容量，而是从逻辑上实现内存容量的扩充。这样计算机就可以运行一些比实际的物理内存大的应用程序。</p><p>虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。</p><h2 id="2-基本思想"><a href="#2-基本思想" class="headerlink" title="2 基本思想"></a>2 基本思想</h2><p>每个程序拥有自己的地址空间，这个地址空间被分为许多个页，每个页都有连续的地址范围。这些页被映射到物理内存，并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p><h2 id="3-分页"><a href="#3-分页" class="headerlink" title="3 分页"></a>3 分页</h2><p>大部分虚拟内存系统中都使用了分页技术。</p><p>下图所示为通过MMU访问内存的过程。</p><p><img src="/img/image-20210609113725447.png" alt="image-20210609113725447"></p><p>由程序产生的地址称为虚拟地址，这些地址构成了一个虚拟地址空间。在没有使用虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上，直接使用该地址访问内存；而在使用了虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到内存管理单元（MMU），然后MMU把虚拟地址映射为物理地址，再使用物理地址访问内存。</p><p><img src="/img/image-20210609110706717.png" alt="image-20210609110706717"></p><p>虚拟地址空间按固定大小被划分成一个个页，在物理内存中对应的页被称为页框。页与页框大小通常是一样的，上图所示的页与页框的大小都是4KB，在实际系统中的页面大小范围为512字节到1GB。</p><p>对于32位机器来说，每个进程的虚拟地址空间为4GB，而实际上是不可能为每个运行中的进程分配4GB的物理内存，所以虚拟内存技术还需要利用交换技术，也就是页面置换算法。在进程运行期间只把需要使用的数据加载到内存，暂时不需要的就写回磁盘保存，需要用到的时候再加载到内存。</p><h2 id="4-页表"><a href="#4-页表" class="headerlink" title="4 页表"></a>4 页表</h2><p>每次进行虚拟地址到物理地址转换的时候，都需要读取页表。页表由多个页表项组成，页表项的结构取决于机器架构。每个进程都有自己的页表。</p><p>不同计算机的页表项大小可能不一样，通常页表项的大小为32位，即4字节。</p><p>一般来说，页表项都会存储物理页框号、修改位、访问位、保护位和“在/不在”位等信息。</p><p>一个典型的页表项如下图所示：</p><p><img src="/img/image-20210609130403516.png" alt="image-20210609130403516"></p><ul><li>物理页框号：指示虚拟页号对应的物理页框号。</li><li>修改位：对页面进行写入时，会由硬件自动设置修改位。该位在操作系统置换页面时很有用，如果页面已被修改，则需要把页面写回到磁盘中，未被修改就不需要。</li><li>访问位：系统在程序访问页面时自动设置的，该位在页面置换时会使用到，操作系统根据页面是否正在使用来决定是否淘汰掉这个页面，不再使用的页面更适合被淘汰。</li><li>保护位：表示该页面允许的访问类型，0表示可读写，1表示只读。</li><li>“在/不在”位：表示页面是否调入内存，1表示已调入内存，0表示页面不在内存中，访问该位为0的页面时会触发一个缺页中断。</li><li>高速缓存禁止位：用于禁止页面放入CPU高速缓存。对那些映射到设备寄存器的页面而言，这一位是很有用的，可以保证硬件是不断地从设备中读取数据而不是从高速缓存中，这样拿到的数据就是最新的。</li></ul><h2 id="5-地址转换"><a href="#5-地址转换" class="headerlink" title="5 地址转换"></a>5 地址转换</h2><p>下图所示为MMU的工作机制。</p><p><img src="/img/image-20210609132627519.png" alt="image-20210609132627519"></p><p>当页面命中时，计算机中各硬件的交互过程：</p><p>（1）CPU生成一个虚拟地址，通过总线发送到MMU；</p><p>（2）MMU通过虚拟地址中的虚拟页号部分得到页表项在页表中的地址，然后从页表（一般位于CPU高速缓存或内存）中读取该页表项；</p><p>（3）页表项经内存总线送至MMU；</p><p>（4）MMU把页表项中的物理页框号复制到寄存器的高3位，然后把虚拟地址中的12位偏移量复制到寄存器的低12位，构成15位物理地址，然后把寄存器中的物理地址发送到内存总线，访问高速缓存或内存；</p><p>（5）高速缓存或内存返回该物理地址对应的数据给CPU。</p><p>当页面未命中时，计算机中各硬件的交互过程：</p><p>（1）（2）（3）步与页面命中的情况是一样的；</p><p>（4）检查页表项，发现“在/不在”位为0，则MMU触发一次缺页中断，然后CPU转去执行操作系统内核的缺页内核的缺页中断处理程序；</p><p>（5）缺页中断处理程序检查虚拟地址是否合法，确认合法后系统检查是否有空闲的页框可以分配，如果没有空闲页框，就进行页面置换；</p><p>（6）缺页中断处理程序从磁盘中把新的页面调入内存，并更新页表项；</p><p>（7）缺页中断处理程序返回到原来的进程，并重新执行引发缺页中断的指令，再按照上述的页面命中的流程继续走一遍。</p><p>实际上，如果一台计算机同时配备了虚拟内存技术和CPU高速缓存，那么MMU每次都会优先尝试到高速缓存中寻址，如果缓存命中就直接返回，不命中就到内存中寻址。如下图所示。</p><p><img src="/img/image-20210609152206170.png" alt="image-20210609152206170"></p><h2 id="6-加速地址转换和大页表问题"><a href="#6-加速地址转换和大页表问题" class="headerlink" title="6 加速地址转换和大页表问题"></a>6 加速地址转换和大页表问题</h2><p>在任何分页系统中，都需要考虑两个主要问题：</p><p>（1）虚拟地址到物理地址的映射要非常快；</p><p>（2）如果虚拟地址空间很大，页表也会很大。</p><h3 id="6-1-加速地址转换的解决方案"><a href="#6-1-加速地址转换的解决方案" class="headerlink" title="6.1 加速地址转换的解决方案"></a>6.1 加速地址转换的解决方案</h3><p><strong>TLB</strong></p><p>加速地址转换目前的解决方案是为计算机设置一个小型的硬件设备，将虚拟地址直接映射到物理地址，而不必再访问页表。这种设备被称为转换检测缓冲区（TLB），也叫快表。它通常位于MMU中，且含有少量的页表项。</p><p>将一个虚拟地址放入MMU中进行转换时，硬件首先通过虚拟地址中的虚拟页号与TLB中所有表项同时并行进行匹配，判断虚拟页面是否在其中。如果发现了一个有效匹配且访问操作不违反保护位，则将页框号直接从TLB中取出。</p><p>若虚拟页号不在TLB中，就会进行正常的页表查询，然后把页表项放入TLB中，若TLB存储空间不足，就会淘汰掉一个页表项，再把新的页表项放进来。</p><h3 id="6-2-大页表问题的解决方案"><a href="#6-2-大页表问题的解决方案" class="headerlink" title="6.2 大页表问题的解决方案"></a>6.2 大页表问题的解决方案</h3><p><strong>多级页表</strong></p><p>把一个大页表进行拆分，形成多级的页表。32位的虚拟地址可以被划分为10位的一级页表索引、10位的二级页表索引和12位的偏移量。</p><p>引入多级页表的原因是避免把全部页表一直保存在内存中，特别是那些从不需要的页表就不应该保留。</p><p><img src="/img/image-20210609141119889.png" alt="image-20210609141119889"></p><p>以上图为例，我们并不需要为一级页表的每个页表项分配一个二级页表，因为对于大部分进程来说，它们的一级页表中含有许多空置的页表项，那么这部分对应的二级页表也无需存在，这样就可以节约内存。</p><p>在程序运行过程中，只需把一级页表驻留在内存中，在实际需要的时候才去创建、调入、调出二级页表，这样就可以确保那些被频繁使用的二级页表常驻在内存中，极大缓解了内存的压力。</p><p><strong>倒排页表</strong></p><p>在倒排页表中，每个页框对应一个表项，而不是每个虚拟页面对应一个表项。</p><p>比如，对于64位虚拟地址，4KB的页，4GB的RAM，一个倒排页表仅需要1048576个表项，表项记录了哪一个（进程，虚拟页面）对应于该页框。</p><p>在虚拟地址空间远大于物理内存时，倒排页表节省了大量的空间，但是它也有不足：从虚拟地址到物理地址的转换会变得很困难。当进程n访问虚拟页面p时，硬件不再能够把p当做索引来查找物理页框了，而是要搜索整个倒排页表，因为基于倒排页表的设计，MMU并不知道是否会发生缺页，所以必须要进行全表扫描，这样就会很低效。</p><p>可以稍作改进，比如使用TLB记录所有频繁使用的页面，TLB命中的情况下就可能跟普通的页表一样快。TLB不命中的情况下，还是需要扫描整个倒排页表。</p><p>线性扫描的方式非常低效，一般的倒排页表会基于哈希表来实现，以物理页框号为key，（虚拟页号，物理页框号）为value，再实现一个哈希函数，以虚拟地址为入参，假设倒排页表的大小为size，则哈希函数最后输出的哈希值在[0,size-1]区间内，具有相同哈希值的虚拟页面被链接在一起。如果哈希表中的槽数与机器中物理页面数一样多，那么哈希表的冲突链的平均长度将会是一个表项长度，这将会大大提高映射速度。一旦页框号被找到，新的（虚拟页号，物理页框号）就会被装载到TLB中。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><p>虚拟内存对于计算机系统来说非常重要，目前还只是学习了虚拟内存技术的几个核心概念，分页、页表、地址变换等。虚拟内存还有页面置换机制没有深入学习，以后慢慢看书沉淀。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚拟内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的排序算法总结</title>
    <link href="/2021/05/22/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2021/05/22/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1-常见的排序算法"><a href="#1-常见的排序算法" class="headerlink" title="1 常见的排序算法"></a>1 常见的排序算法</h2><h3 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h3><p><strong>思想：</strong></p><p>第一轮，从第一个元素开始直到最后一个元素，比较相邻的元素，若前一个元素比后一个元素大，那么就交换，一轮下来，最大的元素就会在最后一个位置。</p><p>第二轮，从第一个元素开始直到倒数第二个元素，重复以上步骤。</p><p>以此类推，假设数组长度为n，则一共经过n-1轮后，数组会排好序。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[j] &gt; nums[j + <span class="hljs-number">1</span>])&#123;<br>                swap(nums,j,j + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>时间复杂度：$O(n^2)$。</p><p>空间复杂度：$O(1)$。</p><p>稳定性：稳定。</p><h3 id="1-2-插入排序"><a href="#1-2-插入排序" class="headerlink" title="1.2 插入排序"></a>1.2 插入排序</h3><p><strong>思想：</strong></p><p>在待排序的数组中，假设前面n-1个元素已经是有序的了，然后把第n个数插入到前面的有序数组，形成n个元素的有序数组。以此类推。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-keyword">if</span>(nums[j] &lt; nums[j-<span class="hljs-number">1</span>])&#123;<br>                swap(nums,j,j-<span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>时间复杂度：$O(n^2)$。</p><p>空间复杂度：$O(1)$。</p><p>稳定性：稳定。</p><h3 id="1-3-选择排序"><a href="#1-3-选择排序" class="headerlink" title="1.3 选择排序"></a>1.3 选择排序</h3><p><strong>思想：</strong></p><p>首先，从数组中找出最小的元素，将它与第一个元素交换，然后在除第一个元素之外的剩余元素中找到最小的元素，与第二个元素交换。以此类推。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">int</span> minIndex = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[j] &lt; nums[minIndex])&#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        swap(nums,i,minIndex);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>时间复杂度：$O(n^2)$。</p><p>空间复杂度：$O(1)$。</p><p>稳定性：不稳定。</p><h3 id="1-4-希尔排序"><a href="#1-4-希尔排序" class="headerlink" title="1.4 希尔排序"></a>1.4 希尔排序</h3><p><strong>思想：</strong></p><p>希尔排序对插入排序做了点改进，先把数组局部排好序，然后最后再插入排序。具体就是让数组中任意距离为h的元素都是有序的，一个h有序的数组相当于h个相互独立的有序数组组织在一起的数组。当h为1的时候，相当于做的是插入排序。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span> h = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//选取合适的h初值</span><br>    <span class="hljs-keyword">while</span>(h &lt; n / <span class="hljs-number">3</span>)&#123;<br>        h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(h &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &gt;= h; j -= h)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j] &lt; nums[j - h])&#123;<br>                    swap(nums,j,j - h);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        h /= <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>时间复杂度：$O(n^{1.3})$。</p><p>空间复杂度：$O(1)$。</p><p>稳定性：不稳定。</p><h3 id="1-5-归并排序"><a href="#1-5-归并排序" class="headerlink" title="1.5 归并排序"></a>1.5 归并排序</h3><p><strong>思想：</strong></p><p>采用分治的思想，先将数组的两个子数组排好序，再把它们合并成一个整体有序的数组。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>    mergeSort(nums,left,mid,temp);<br>    mergeSort(nums,mid + <span class="hljs-number">1</span>,right,temp);<br>    <span class="hljs-comment">//归并</span><br>    <span class="hljs-keyword">int</span> i = left;<br>    <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> index = left;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &lt;= nums[j])&#123;<br>            temp[index++] = nums[i++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            temp[index++] = nums[j++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid)&#123;<br>        temp[index++] = nums[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j &lt;= right)&#123;<br>        temp[index++] = nums[j++];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = left; k &lt;= right; k++)&#123;<br>        nums[k] = temp[k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>时间复杂度：$O(nlog_2n)$。</p><p>空间复杂度：$O(n)$。</p><p>稳定性：稳定。</p><h3 id="1-6-快速排序"><a href="#1-6-快速排序" class="headerlink" title="1.6 快速排序"></a>1.6 快速排序</h3><p><strong>思想：</strong></p><p>首先选取一个基准（一般选数组第一个元素），把数组中小于基准值的元素全放到基准值的左边，大于基准值的元素全放到基准值的右边。再对基准值左右两边的数组重复此操作。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> key = nums[left];<br>    <span class="hljs-keyword">int</span> first = left;<br>    <span class="hljs-keyword">int</span> last = right;<br>    <span class="hljs-keyword">while</span>(first &lt; last)&#123;<br>        <span class="hljs-keyword">while</span>(first &lt; last &amp;&amp; nums[last] &gt;= key)&#123;<br>            last--;<br>        &#125;<br>        nums[first] = nums[last];<br>        <span class="hljs-keyword">while</span>(first &lt; last &amp;&amp; nums[first] &lt;= key)&#123;<br>            first++;<br>        &#125;<br>        nums[last] = nums[first];<br>    &#125;<br>    nums[first] = key;<br>    quickSort(nums,left,first - <span class="hljs-number">1</span>);<br>    quickSort(nums,first + <span class="hljs-number">1</span>,right);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>时间复杂度：$O(nlog_2n)$。</p><p>空间复杂度：$O(nlog_2n)$。</p><p>稳定性：不稳定。</p><h3 id="1-7-堆排序"><a href="#1-7-堆排序" class="headerlink" title="1.7 堆排序"></a>1.7 堆排序</h3><p><strong>思想：</strong></p><p>堆是一个近似完全二叉树的结构，根节点总是存放最大值或者最小值。</p><p>假设数组长度为n，以大顶堆为例，将待排序数组构造成一个大顶堆，此时堆的根节点存放的就是最大值，然后将最大值与数组的末尾元素交换，再把剩下的n-1个元素重新构造成一个大顶堆，重复操作，数组就会排好序。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">//构造大顶堆，从最后一个非叶节点开始</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        adjustHeap(nums,i,n);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-comment">//每次构造完大顶堆后，数组的第一个元素都是最大值，将其交换到末尾</span><br>        swap(nums,<span class="hljs-number">0</span>,i);<br>        <span class="hljs-comment">//交换元素后，调整堆结构，使其仍然保持为大顶堆</span><br>        <span class="hljs-comment">//从索引为0的节点开始调整，是因为下层的节点仍然满足大顶堆的要求，不受交换元素的影响</span><br>        adjustHeap(nums,<span class="hljs-number">0</span>,i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> root, <span class="hljs-keyword">int</span> heapSize)</span></span>&#123;<br>    <span class="hljs-comment">//j保存根节点的索引</span><br>    <span class="hljs-keyword">int</span> j = root;<br>    <span class="hljs-comment">//使用循环，是因为在调整高层节点的结构时可能会影响下层节点的结构</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span> * root + <span class="hljs-number">1</span>; k &lt; heapSize; k = <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(k + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; nums[k] &lt; nums[k + <span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-comment">//使k指向最大的子节点</span><br>            k++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[j] &lt; nums[k])&#123;<br>            swap(nums,j,k);<br>            j = k;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>时间复杂度：$O(nlog_2n)$。</p><p>空间复杂度：$O(1)$。</p><p>稳定性：不稳定。</p><h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2 总结"></a>2 总结</h2><div class="table-container"><table><thead><tr><th style="text-align:center">排序方法</th><th style="text-align:center">时间复杂度（平均）</th><th>时间复杂度（最好）</th><th>时间复杂度（最坏）</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">$O(n^{1.3})$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">$O(nlog_2n)$</td><td>$O(nlog_2n)$</td><td>$O(nlog_2n)$</td><td>$O(n)$</td><td>稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">$O(nlog_2n)$</td><td>$O(nlog_2n)$</td><td>$O(n^2)$</td><td>$O(nlog_2n)$</td><td>不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">$O(nlog_2n)$</td><td>$O(nlog_2n)$</td><td>$O(nlog_2n)$</td><td>$O(1)$</td><td>不稳定</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
